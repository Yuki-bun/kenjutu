## Project Overview

Kenjutu is a Tauri 2 desktop application for viewing diffs / GitHub pull requests locally,
focusing on a per-commit review workflow with first-class Jujutsu (jj) support.
A companion TUI app (`src-tui`) provides the same per-commit review workflow in the terminal using Ratatui.

## Development Commands

```bash
# Build for production (takes a lot of time. Don't run this command for type checking)
pnpm tauri build

# Type checking
pnpm check

# Generate ts bindings for tauri commands
pnpm gen

# Cargo commands are available from the root of this repository
cargo build ....
```

## Architecture

### Frontend (`/src`)

- **React 19** with **TanStack Router** (file-based routing in `/src/routes`)
- **TanStack Query** for data fetching
- **shadcn/ui** components in `/src/components/ui`
- **Octokit** for GitHub API calls (runs in frontend, not backend)
- Path alias: `@/` maps to `./src/`

### Backend (`/src-tauri`)

- **Rust with Tauri 2** framework
- **git2** for local git operations (diff generation, commit lookup)
- **jj CLI** invoked as a subprocess for status checks, commit description, and log graph
- **two-face/Syntect** for syntax highlighting
- **tauri-specta** auto-generates TypeScript bindings from Rust commands

### TUI (`/src-tui`)

- **Ratatui** terminal UI with **Crossterm** backend
- **Commit log screen** — scrollable jj commit graph with inline describe and `jj new`
- **Review screen** — split-pane file list + syntax-highlighted diff with hunk-level review tracking
- Uses `kenjutu-core` and `marker-commit` directly (no Tauri dependency)
- CLI entry point: `kenjutu [--dir <path>]`

### Workspace Crates

- **kenjutu-core** (`crates/kenjutu-core`) — shared business logic (git, jj, diff, highlighting, models) used by both the Tauri backend and the TUI
- **kenjutu-types** (`crates/kenjutu-types`) — newtype ID wrappers (`ChangeId`, `CommitId`)
- **marker-commit** (`crates/marker-commit`) — persists review state as git objects
- **test-repo** (`crates/test-repo`) — test utility for temporary jj/git repositories

### Key Directories

- `/src/routes` - Page components (file-based routing)
  - Route-specific hooks live in a `-hooks/` subdirectory (e.g., `pulls.$owner.$repo.$number/-hooks/`)
  - Route-specific components live in a `-components/` subdirectory
- `/src/components` - Shared components (`ui/` for shadcn/ui primitives)
- `/src/hooks` - Global custom hooks
- `/src/lib` - Utility modules
- `/src/context` - React contexts
- `/src-tauri/src/commands` - Tauri IPC command handlers (`auth`, `jj`, `pr`, `repo`)
- `/src-tauri/src/services` - Tauri-specific services (`auth`)
- `/src-tauri/src/models` - Tauri-specific models (`auth`); re-exports `kenjutu_core::models`
- `/crates/kenjutu-core/src/services` - Core business logic (`diff`, `git`, `graph`, `highlight`, `jj`, `word_diff`)
- `/crates/kenjutu-core/src/models` - Shared data types (`jj`, `pr`)

### Query pattern

- Uses TanStack Query
- Register query keys in `/src/lib/queryKeys.ts`
- Invalidation should use keys from `/src/lib/queryKeys.ts`

### Data Flow

1. GitHub API calls happen in the frontend via Octokit
2. Repo registry (GitHub repo ID → local path) stored in Tauri Store on frontend
3. Local git operations (diffs, commits) go through Tauri commands to the Rust backend (frontend passes `localDir` to commands)
4. **Review state is persisted as git objects** via the `marker_commit` crate — no SQLite database

### Jujutsu Integration

The app has deep jj integration:

- `services/jj.rs` (in `kenjutu-core`) invokes the `jj` CLI binary for status checks and commit description
- `services/graph.rs` (in `kenjutu-core`) invokes `jj log` to build the commit graph
- `commands/jj.rs` exposes `get_jj_log`, `get_jj_status`, and `describe_commit` to the frontend
- `get_commits_in_range` (in `commands/pr.rs`) delegates to `git::get_commits_in_range` for walking the commit range
- The `LocalRepo` view (`/localRepo/$dir`) shows a jj commit graph powered by `JjCommit` data
- `ShaToChangeIdContext` maps GitHub PR commit SHAs to jj ChangeIds for review tracking on PRs

### Review Tracking

Review state is stored as **marker commits** (git objects in the local repo) via the `marker-commit` crate.

### IPC Pattern

Rust commands in `/src-tauri/src/commands/` return `Result<T, Error>` (tagged union serialized with `serde`). TypeScript bindings are auto-generated by tauri-specta. Call Tauri commands via the custom `useRpcQuery` / `useRpcMutation` hooks at `src/hooks/useRpcQuery.ts`.

### Models

- `kenjutu-types` — `ChangeId`, `CommitId` newtype wrappers
- `kenjutu-core/models/jj.rs` — `JjCommit`, `JjLogResult`, `JjStatus`, `CommitGraph`, `GraphRow`, `CommitRow`, `ElisionRow`, `GraphEdge`, `EdgeType`
- `kenjutu-core/models/pr.rs` — `PRCommit`, `FileEntry`, `CommitFileList`, `FileDiff`, `DiffHunk`, `DiffLine`, `HighlightToken`, `FileChangeStatus`, `DiffLineType`, `HunkId`, `ReviewStatus`
- `src-tauri/models/auth.rs` — auth-related types

## Code Style

- No semicolons
- Newtype wrappers for IDs: `ChangeId`, `CommitId` in `crates/kenjutu-types`

## Version Control

- Use jujutsu to create commits
- Large changes should be split into multiple commits with clear messages
- Do not create a commit that fixes a previous commit; instead modify the old revision with jujutsu commands
- Never use git commands to create or modify commits, always use jujutsu
- Before running jujutsu commands always check the current state with `jj log`
- Run `pnpm fmt` & `pnpm lint` before committing
- For a sufficiently large change, in the plan stage document stage at which a commit will be created.
- Each commit should pass all the lints and tests.
