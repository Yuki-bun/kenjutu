## Project Overview

Kenjutu is a Tauri 2 desktop application for viewing diffs / GitHub pull requests locally,
focusing on a per-commit review workflow with first-class Jujutsu (jj) support.

## Development Commands

```bash
# Build for production (takes a lot of time. Don't run this command for type checking)
pnpm tauri build

# Type checking
pnpm check

# Generate ts bindings for tauri commands
pnpm gen

# Cargo commands are available from the root of this repository
cargo build ....
```

## Architecture

### Frontend (`/src`)

- **React 19** with **TanStack Router** (file-based routing in `/src/routes`)
- **TanStack Query** for data fetching
- **shadcn/ui** components in `/src/components/ui`
- **Octokit** for GitHub API calls (runs in frontend, not backend)
- Path alias: `@/` maps to `./src/`

### Backend (`/src-tauri`)

- **Rust with Tauri 2** framework
- **git2** for local git operations (diff generation, commit lookup)
- **jj CLI** invoked as a subprocess via `services/jj.rs` for commit log and range queries
- **two-face/Syntect** for syntax highlighting
- **tauri-specta** auto-generates TypeScript bindings from Rust commands

#### Workspace Crates

- **marker-commit** crate for persisting review state as git objects
- **test-repo** crate for testing with temporary git repositories

### Key Directories

- `/src/routes` - Page components (file-based routing)
  - Route-specific hooks live in a `-hooks/` subdirectory (e.g., `pulls.$owner.$repo.$number/-hooks/`)
  - Route-specific components live in a `-components/` subdirectory
- `/src/components` - Shared components (`ui/` for shadcn/ui primitives)
- `/src/hooks` - Global custom hooks
- `/src/lib` - Utility modules
- `/src/context` - React contexts
- `/src-tauri/src/commands` - Tauri IPC command handlers (`auth`, `jj`, `pr`, `repo`)
- `/src-tauri/src/services` - Business logic (`auth`, `diff`, `git`, `highlight`, `jj`, `word_diff`)
- `/src-tauri/src/models` - Shared data types (`entities`, `jj`, `pr`, `auth`)

### Query pattern

- Uses TanStack Query
- Register query keys in `/src/lib/queryKeys.ts`
- Invalidation should use keys from `/src/lib/queryKeys.ts`

### Data Flow

1. GitHub API calls happen in the frontend via Octokit
2. Repo registry (GitHub repo ID → local path) stored in Tauri Store on frontend
3. Local git operations (diffs, commits) go through Tauri commands to the Rust backend (frontend passes `localDir` to commands)
4. **Review state is persisted as git objects** via the `marker_commit` crate — no SQLite database

### Jujutsu Integration

The app has deep jj integration:

- `services/jj.rs` invokes the `jj` CLI binary to fetch commit logs and commit ranges
- `commands/jj.rs` exposes `get_jj_log` and `get_jj_status` to the frontend
- `get_commits_in_range` (in `commands/pr.rs`) stores fetched commits under `refs/remotes/kenjutu` via `store_commit_as_fake_remote` so jj can find them by SHA, then delegates to `jj::get_commits_in_range`
- The `LocalRepo` view (`/localRepo/$dir`) shows a jj commit graph powered by `JjCommit` data
- `ShaToChangeIdContext` maps GitHub PR commit SHAs to jj ChangeIds for review tracking on PRs

### Review Tracking

Review state is stored as **marker commits** (git objects in the local repo) via the `marker-commit` crate.

### IPC Pattern

Rust commands in `/src-tauri/src/commands/` return `Result<T, CommandError>` (tagged union serialized with `serde`). TypeScript bindings are auto-generated by tauri-specta. Call Tauri commands via the custom `useRpcQuery` / `useRpcMutation` hooks at `src/hooks/useRpcQuery.ts`.

### Models

- `models/entities.rs` — `PatchId`, `ChangeId` newtype wrappers
- `models/jj.rs` — `JjCommit`, `JjLogResult`, `JjStatus`
- `models/pr.rs` — `PRCommit`, `FileEntry`, `CommitFileList`, `FileDiff`, `DiffHunk`, `DiffLine`, `HighlightToken`, `FileChangeStatus`, `DiffLineType`
- `models/auth.rs` — auth-related types

## Code Style

- No semicolons
- Newtype wrappers for IDs: `PatchId`, `ChangeId` in `/src-tauri/src/models/entities.rs`

## Version Control

- Use jujutsu to create commits
- Large changes should be split into multiple commits with clear messages
- Do not create a commit that fixes a previous commit; instead modify the old revision with jujutsu commands
- Never use git commands to create or modify commits, always use jujutsu
- Before running jujutsu commands always check the current state with `jj log`
- Run `pnpm fmt` & `pnpm lint` before committing
